# file opened: rollscr.z80
  1   0000              ; Rolling 1s and 0s Print-by-Character Screen Color Display Test
  2   0000
  3   0000                      DEVICE  ZXSPECTRUM48
  4   0000
  5   0000                      org $8000
  6   8000
  7   8000              ; constants
  8   8000              STACK_POS       equ $FF50       ; near end of available memory
  9   8000              SCR_START       equ $4000       ; start of screen memory
 10   8000              SCR_RAM         equ $1800       ; total screen memory
 11   8000              ATR_START       equ $5800       ; start of screen attribute memory
 12   8000              ATR_RAM         equ $0300       ; total attribute memory
 13   8000              WAIT_TIME       equ $01         ; number of delay loops
 14   8000              AREA_CHAR       equ $0100       ; characters per area
 15   8000              NEXT_AREA       equ $0800       ; space until next area
 16   8000              COLORS  equ spbak-colormap      ; size of color map data block
 17   8000
 18   8000              ; main routine
 19   8000              start:
 20   8000 D9                   exx             ; swap registers
 21   8001 E5                   push hl         ; store hl' for basic
 22   8002 ED 73 2B 80          ld (spbak),sp   ; backup original stack
 23   8006 31 50 FF             ld sp,STACK_POS ; set custom program stack
 24   8009
 25   8009 FD 21 19 80          ld iy,colormap  ; set color pointer register
 26   800D 06 09                ld b,COLORS/2   ; number of color words
 27   800F CD 30 80             call roll       ; rolling color loop routine
 28   8012
 29   8012 ED 7B 2B 80          ld sp,(spbak)   ; restore system stack pointer
 30   8016 E1                   pop hl          ; restore hl' for basic
 31   8017 D9                   exx             ; swap registers
 32   8018 C9                   ret
 33   8019
 34   8019              ; program data
 35   8019              colormap:
 36   8019 38 01 0A 13          db $38,$01,$0A,$13,$1C,$25,$2E,$37      ; normal color cycle
 36   801D 1C 25 2E 37
 37   8021 38 41 4A 53          db $38,$41,$4A,$53,$5C,$65,$6E,$77      ; bright color cycle
 37   8025 5C 65 6E 77
 38   8029 78 07                db $78,$07                              ; reset screen
 39   802B              spbak:
 40   802B 00 00                dw 0            ; back up system stack pointer
 41   802D              spbuff:
 42   802D 00 00                dw 0            ; back up program stack pointer
 43   802F              mode:
 44   802F 00                   db 0            ; print mode 1-set, 0-reset
 45   8030
 46   8030              ; rolling color loop routine
 47   8030              roll:
 48   8030 C5                   push bc         ; store current loop
 49   8031 3E 01                ld a,1          ; 1 = set mode
 50   8033 32 2F 80             ld (mode),a     ; set mode to set
 51   8036 21 00 40             ld hl,SCR_START ; set hl to start of screen memory
 52   8039 06 03                ld b,3          ; number of areas
 53   803B CD 53 80             call screen     ; run screen print routine
 54   803E FD 23                inc iy          ; move to next color code
 55   8040 3E 00                ld a,0          ; 0 = reset mode
 56   8042 32 2F 80             ld (mode),a     ; set mode to reset
 57   8045 21 00 40             ld hl,SCR_START ; set hl to start of screen memory
 58   8048 06 03                ld b,3          ; number of areas
 59   804A CD 53 80             call screen     ; run screen print routine
 60   804D FD 23                inc iy          ; move to next color code
 61   804F C1                   pop bc          ; restore current loop
 62   8050 10 DE                djnz roll       ; loop for all color words
 63   8052 C9                   ret
 64   8053
 65   8053              ; screen print routine
 66   8053              screen:
 67   8053 C5                   push bc         ; store current loop
 68   8054 E5                   push hl         ; store first line of area
 69   8055 01 00 01             ld bc,AREA_CHAR ; number of characters per area
 70   8058 3E FF                ld a,$FF        ; store for checking underflow
 71   805A CD 66 80             call area       ; run area print routine
 72   805D E1                   pop hl          ; restore first area character
 73   805E 01 00 08             ld bc,NEXT_AREA ; stage next area differential
 74   8061 09                   add hl,bc       ; add distance to next area
 75   8062 C1                   pop bc          ; restore current loop
 76   8063 10 EE                djnz screen     ; loop over 3 screen areas
 77   8065 C9                   ret
 78   8066
 79   8066              ; area print routine
 80   8066              area:
 81   8066 C5                   push bc         ; store current loop
 82   8067 E5                   push hl         ; store top line of character
 83   8068 06 08                ld b,8          ; number of color runs
 84   806A 0E 00                ld c,0          ; set c to reset mode
 85   806C 3A 2F 80             ld a,(mode)     ; pull current mode
 86   806F A9                   xor c           ; compare mode
 87   8070 20 05                jr nz,fillmode
 88   8072 CD 8F 80             call empty      ; empty screen routine
 89   8075 18 03                jr contin
 90   8077              fillmode:
 91   8077 CD 83 80             call fill       ; fill screen routine
 92   807A              contin:
 93   807A E1                   pop hl          ; restore top line of character
 94   807B C1                   pop bc          ; restore current loop
 95   807C 23                   inc hl          ; move to next character position
 96   807D 0B                   dec bc          ; decrement loop counter
 97   807E 78                   ld a,b          ; prepare to compare high/low bytes
 98   807F B1                   or c            ; check if loop counter is zero
 99   8080 20 E4                jr nz,area      ; loop for all area characters
100   8082 C9                   ret
101   8083
102   8083              ; fill character print routine
103   8083              fill:
104   8083 CD 9B 80             call wait       ; delay loop
105   8086 37                   scf             ; set carry flag
106   8087 CB 1E                rr (hl)         ; rotate bits right with carry
107   8089 30 F8                jr nc,fill      ; loop while carry is 0
108   808B 24                   inc h           ; increment high bit
109   808C 10 F5                djnz fill       ; loop for all 8 lines
110   808E C9                   ret
111   808F
112   808F              ; empty character print routine
113   808F              empty:
114   808F CD 9B 80             call wait       ; delay loop
115   8092 3F                   ccf             ; clear carry flag
116   8093 CB 1E                rr (hl)         ; rotate bits right with carry
117   8095 38 F8                jr c,empty      ; loop while carry is 1
118   8097 24                   inc h           ; increment high bit
119   8098 10 F5                djnz empty      ; loop for all 8 lines
120   809A C9                   ret
121   809B
122   809B              ; delay subroutine
123   809B              wait:
124   809B C5                   push bc         ; store current loop
125   809C 06 01                ld b,WAIT_TIME  ; set number of nops
126   809E              waitloop:
127   809E 00                   nop             ; do nothing
128   809F 10 FD                djnz waitloop   ; loop for all nops
129   80A1 C1                   pop bc          ; restore current loop
130   80A2 C9                   ret
131   80A3
132   80A3              ; deploy snapshot file
133   80A3                      SAVESNA "rollscr.sna", start
# file closed: rollscr.z80
